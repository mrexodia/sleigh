/*
  Copyright (c) 2021-present, Trail of Bits, Inc.
  All rights reserved.

  This source code is licensed in accordance with the terms specified in
  the LICENSE file found in the root directory of this source tree.
*/

#include <sleigh/libsleigh.hh>

#include <cassert>
#include <iostream>
#include <string>

// NOTE: The ghidra symbols should be fully-qualified after the 'ghidra'
// namespace changes make it into a stable release
#ifdef sleigh_RELEASE_IS_HEAD
using namespace ghidra;
#endif

static void PrintUsage(std::ostream &os) {
  os << "Usage: sleigh-lift [action] [sla_file] [bytes] [-a address] "
        "[-p root_sla_dir] [-s pspec_file]"
     << std::endl;
}

static void PrintVersion(void) {
  std::cout << "sleigh-lift " << sleigh::GetGhidraVersion() << '\n';

  // Print out the commit info for the underlying GHIDRA checkout
  std::cout << "GHIDRA Version: " << sleigh::GetGhidraVersion() << '\n'
            << "GHIDRA Commit Hash: " << sleigh::GetGhidraCommitHash() << '\n'
            << "GHIDRA Release Type: " << sleigh::GetGhidraReleaseType()
            << '\n';

  // Now print out the Git commit information
  if (sleigh::HasVersionData()) {
    std::cout << "Commit Hash: " << sleigh::GetCommitHash() << '\n'
              << "Commit Date: " << sleigh::GetCommitDate() << '\n'
              << "Last commit by: " << sleigh::GetAuthorName() << " ["
              << sleigh::GetAuthorEmail() << "]\n"
              << "Commit Subject: [" << sleigh::GetCommitSubject() << "]\n"
              << '\n';
    if (sleigh::HasUncommittedChanges()) {
      std::cout << "Uncommitted changes were present during build.\n";
    } else {
      std::cout << "All changes were committed prior to building.\n";
    }
  } else {
    std::cout << "No extended version information found!\n";
  }
}

class InMemoryLoadImage : public LoadImage {
public:
  explicit InMemoryLoadImage(uint64_t base_addr)
      : LoadImage("nofile"), base_addr(base_addr) {}

  void SetImageBuffer(std::string &&buf) {
    assert(image_buffer.empty());
    image_buffer = std::move(buf);
  }

  void loadFill(unsigned char *ptr, int size, const Address &addr) override {
    uint64_t start = addr.getOffset();
    for (int i = 0; i < size; ++i) {
      uint64_t offset = start + i;
      if (offset >= base_addr) {
        offset -= base_addr;
        ptr[i] = offset < image_buffer.size() ? image_buffer[offset] : 0;
      } else {
        ptr[i] = 0;
      }
    }
  }

  std::string getArchType(void) const override { return "memory"; }
  void adjustVma(long) override {}

private:
  const uint64_t base_addr;
  std::string image_buffer;
};

static std::string ParseHexBytes(std::string_view bytes, uint64_t addr,
                                 uint64_t addr_size) {
  std::string buffer;
  for (size_t i = 0; i < bytes.size(); i += 2) {
    const char nibbles[] = {bytes[i], bytes[i + 1], '\0'};
    char *parsed_to = nullptr;
    auto byte_val = strtol(nibbles, &parsed_to, 16);
    if (parsed_to != &(nibbles[2])) {
      std::cerr << "Invalid hex byte value '" << nibbles
                << "' specified in bytes arg." << std::endl;
      exit(EXIT_FAILURE);
    }
    const uint64_t addr_mask = ~0ULL >> (64UL - addr_size * 8);
    auto byte_addr = addr + (i / 2);
    auto masked_addr = byte_addr & addr_mask;
    // Make sure that if a really big number is specified for `address`,
    // that we don't accidentally wrap around and start filling out low
    // byte addresses.
    if (masked_addr < byte_addr) {
      std::cerr << "Too many bytes specified to bytes arg, would result "
                << "in a 32-bit overflow.";
      exit(EXIT_FAILURE);
    } else if (masked_addr < addr) {
      std::cerr << "Too many bytes specified to bytes arg, would result "
                << "in a 64-bit overflow.";
      exit(EXIT_FAILURE);
    }
    buffer.push_back(static_cast<char>(byte_val));
  }
  return buffer;
}

class AssemblyPrinter : public AssemblyEmit {
public:
  void dump(const Address &addr, const std::string &mnemonic,
            const std::string &body) override {
    addr.printRaw(std::cout);
    std::cout << ": " << mnemonic << ' ' << body << std::endl;
  }
};

static void PrintAssembly(Sleigh &engine, uint64_t addr, size_t len) {
  AssemblyPrinter asm_emit;
  Address cur_addr(engine.getDefaultCodeSpace(), addr),
      last_addr(engine.getDefaultCodeSpace(), addr + len);
  while (cur_addr < last_addr) {
    int32_t instr_len = engine.printAssembly(asm_emit, cur_addr);
    cur_addr = cur_addr + instr_len;
  }
}

class PcodePrinter : public PcodeEmit {
  std::ostream &s;
  Address instructionAddr;
  uint32_t pcodeAddr = 0;

public:
  PcodePrinter(std::ostream &s) : s(s) {}

  void dump(const Address &addr, OpCode op, VarnodeData *outvar,
            VarnodeData *vars, int32_t isize) override {
    if (addr != instructionAddr) {
      instructionAddr = addr;
      pcodeAddr = 0;
    } else {
      pcodeAddr++;
    }
    s << "0x" << std::setw(2) << std::hex << pcodeAddr << ": ";
    if (outvar) {
      PrintVarData(op, *outvar);
      std::cout << " = ";
    }
    std::cout << get_opname(op);
    for (int32_t i = 0; i < isize; ++i) {
      std::cout << ' ';
      PrintVarData(op, vars[i]);
    }
    std::cout << std::endl;
  }

private:
  void PrintVarData(OpCode op, VarnodeData &data) {
    auto space = data.space;
    const auto &name = space->getName();
    if (op == OpCode::CPUI_BRANCH ||
        op == OpCode::CPUI_CBRANCH && name == "const") {
      s << '(' << name << ',';
      auto rel = (intb)data.offset;
      if (rel < 0) {
        s << "-0x" << std::setw(2) << std::hex << -rel;
      } else {
        s << "+0x" << std::setw(2) << std::hex << rel;
      }
      s << ',' << std::dec << data.size << ')';
      s << ":0x" << std::setw(2) << std::hex << pcodeAddr + rel;
    } else {
      s << '(' << name << ',';
      data.space->printOffset(s, data.offset);
      s << ',' << std::dec << data.size << ')';
      if (name == "register") {
        auto regname = space->getTrans()->getRegisterName(
            data.space, data.offset, data.size);
        s << ':' << regname;
      }
    }
  }
};

class AssemblyRaw : public AssemblyEmit {
public:
  virtual void dump(const Address &addr, const std::string &mnem,
                    const std::string &body) {
    addr.printRaw(std::cout);
    std::cout << ": " << mnem << ' ' << body << std::endl;
  }
};

static void PrintPcode(Sleigh &engine, uint64_t addr, size_t len) {
  PcodePrinter pcode_emit(std::cout);
  Address cur_addr(engine.getDefaultCodeSpace(), addr),
      last_addr(engine.getDefaultCodeSpace(), addr + len);
  AssemblyRaw assememit;
  while (cur_addr < last_addr) {
    std::cout << "=> ";
    engine.printAssembly(assememit, cur_addr);
    int32_t instr_len = engine.oneInstruction(pcode_emit, cur_addr);
    cur_addr = cur_addr + instr_len;
  }
}

class HaltCallBack : public BreakCallBack {
  bool pcodeCallback(PcodeOpRaw *op) override {
    emulate->setHalt(true);
    return true;
  }
  bool addressCallback(const Address &addr) override {
    emulate->setHalt(true);
    return true;
  }
};

#include <chrono>

static void EmulatePcode(Sleigh &engine, uint64_t addr, size_t len,
                         InMemoryLoadImage &load_image) {
  // Cobbled together from documentation in emulate.hh

  // Set up memory state object
  MemoryImage loadmemory(engine.getDefaultCodeSpace(), 8, 4096, &load_image);
  MemoryPageOverlay ramstate(engine.getDefaultCodeSpace(), 8, 4096,
                             &loadmemory);
  MemoryHashOverlay registerstate(engine.getSpaceByName("register"), 8, 4096,
                                  4096, (MemoryBank *)0);
  MemoryHashOverlay tmpstate(engine.getUniqueSpace(), 8, 4096, 4096,
                             (MemoryBank *)0);

  // Instantiate the memory state object
  MemoryState memstate(&engine);
  memstate.setMemoryBank(&ramstate);
  memstate.setMemoryBank(&registerstate);
  memstate.setMemoryBank(&tmpstate);

  // Instantiate a breakpoint table
  BreakTableCallBack breaktable(&engine);
  EmulatePcodeCache emulator(&engine, &memstate, &breaktable);

  // Stop emulation when reaching the return address
  Address returnAddr(engine.getDefaultDataSpace(), 0x1337);
  HaltCallBack halt;
  breaktable.registerAddressCallback(returnAddr, &halt);

  // Set up a stack
  auto rsp = 0xbffffffc;
  memstate.setValue("RSP", rsp);
  VarnodeData ptr{engine.getDefaultDataSpace(), rsp, 8};
  memstate.setValue(&ptr, returnAddr.getOffset());

  // Start execution
  emulator.setHalt(false);
  emulator.setExecuteAddress(Address(engine.getDefaultCodeSpace(), addr));

  const bool trace = false;
  AssemblyRaw assememit;
  auto count = 0;
  auto last = std::chrono::system_clock::now();
  while (!emulator.getHalt()) {
    auto now = std::chrono::system_clock::now();
    if ((now - last) >= std::chrono::seconds(1)) {
      last = now;
      printf("%d instructions/second\n", count);
      count = 0;
    } else {
      count++;
    }
    if (trace) {
      Address addr = emulator.getExecuteAddress();
      engine.printAssembly(assememit, addr);
    }
    emulator.executeInstruction();
  }
}

struct LiftArgs {
  const std::string action, sla_file_name, bytes;
  const std::optional<uint64_t> addr;
  const std::optional<std::string> root_sla_dir, pspec_file_name;
};

std::optional<LiftArgs> ParseArgs(int argc, char *argv[]) {
  // Too few args
  if (argc < 4) {
    return {};
  }

  // Get positional args
  int arg_index = 1;
  std::string action = argv[arg_index++];
  std::string sla_file_name = argv[arg_index++];
  std::string bytes = argv[arg_index++];
  if (bytes.size() % 2 != 0) {
    std::cerr << "Must provide an even number of bytes: " << bytes << std::endl;
    return {};
  }

  // Get optional args
  std::optional<uint64_t> addr;
  std::optional<std::string> root_sla_dir, pspec_file_name;
  while (arg_index < argc) {
    const std::string flag = argv[arg_index++];
    if (arg_index == argc) {
      std::cerr << "Flag " << flag << " has no value" << std::endl;
      return {};
    }
    if (flag == "-a") {
      if (addr) {
        std::cerr << "-a flag provided multiple times" << std::endl;
        return {};
      }
      const char *addr_str = argv[arg_index++];
      try {
        addr = std::stoul(addr_str);
      } catch (const std::invalid_argument &) {
        std::cerr << "Invalid address argument: " << addr_str << std::endl;
        return {};
      } catch (const std::out_of_range &) {
        std::cerr << "Address argument out of range: " << addr_str << std::endl;
        return {};
      }
    } else if (flag == "-p") {
      if (root_sla_dir) {
        std::cerr << "-p flag provided multiple times" << std::endl;
        return {};
      }
      root_sla_dir = argv[arg_index++];
    } else if (flag == "-s") {
      if (pspec_file_name) {
        std::cerr << "-s flag provided multiple times" << std::endl;
        return {};
      }
      pspec_file_name = argv[arg_index++];
    } else {
      std::cerr << "Unrecognised optional flag: " << flag << std::endl;
      return {};
    }
  }
  return LiftArgs{std::move(action),       std::move(sla_file_name),
                  std::move(bytes),        addr,
                  std::move(root_sla_dir), std::move(pspec_file_name)};
}

int main(int argc, char *argv[]) {
  // Check for `--help` or `--version`
  if (argc == 2) {
    const std::string cmd = argv[1];
    if (cmd == "--help") {
      PrintUsage(std::cout);
      return EXIT_SUCCESS;
    } else if (cmd == "--version") {
      PrintVersion();
      return EXIT_SUCCESS;
    }
  }
  const auto args = ParseArgs(argc, argv);
  if (!args) {
    PrintUsage(std::cerr);
    return EXIT_FAILURE;
  }
  const uint64_t addr = args->addr ? *args->addr : 0;
  // Find SLA file path
  const auto sla_file_path =
      args->root_sla_dir
          ? sleigh::FindSpecFile(args->sla_file_name, {*args->root_sla_dir})
          : sleigh::FindSpecFile(args->sla_file_name);
  if (!sla_file_path) {
    std::cerr << "Could not find SLA file: " << args->sla_file_name
              << std::endl;
    return EXIT_FAILURE;
  }
  // Put together Sleigh components
  AttributeId::initialize();
  ElementId::initialize();
  InMemoryLoadImage load_image(addr);
  ContextInternal ctx;
  Sleigh engine(&load_image, &ctx);
  DocumentStorage storage;
  Element *root = storage.openDocument(sla_file_path->string())->getRoot();
  storage.registerTag(root);
  std::optional<std::filesystem::path> pspec_file_path;
  if (args->pspec_file_name) {
    // A PSPEC file was explicitly supplied
    pspec_file_path = args->root_sla_dir
                          ? sleigh::FindSpecFile(*args->pspec_file_name,
                                                 {*args->root_sla_dir})
                          : sleigh::FindSpecFile(*args->pspec_file_name);
    if (!pspec_file_path) {
      std::cerr << "Could not find PSPEC file: " << *args->pspec_file_name
                << std::endl;
      return EXIT_FAILURE;
    }
  } else {
    // Otherwise, see if there's a PSPEC file named identically to the SLA file
    pspec_file_path = *sla_file_path;
    pspec_file_path->replace_extension(".pspec");
    if (!std::filesystem::exists(*pspec_file_path)) {
      // If a file with that extension doesn't exist, don't attempt to load it
      pspec_file_path = {};
    }
  }
  if (pspec_file_path) {
    Element *pspec_root =
        storage.openDocument(pspec_file_path->string())->getRoot();
    storage.registerTag(pspec_root);
  }
  engine.initialize(storage);
  engine.allowContextSet(false);
  // Now that context symbol names are loaded by the translator
  // we can set the default context
  // This imitates what is done in
  //   void Architecture::parseProcessorConfig(DocumentStorage &store)
  const Element *el = storage.getTag("processor_spec");
  if (el) {
    XmlDecode decoder(&engine, el);
    uint4 elemId = decoder.openElement(ELEM_PROCESSOR_SPEC);
    for (;;) {
      uint4 subId = decoder.peekElement();
      if (subId == 0)
        break;
      else if (subId == ELEM_CONTEXT_DATA) {
        ctx.decodeFromSpec(decoder);
        break;
      } else {
        decoder.openElement();
        decoder.closeElementSkipping(subId);
      }
    }
    decoder.closeElement(elemId);
  }

  // In order to parse and validate the byte string properly, we need to get the
  // address size from Sleigh. Therefore this needs to happen after
  // initialization.
  //
  // Ensure that we don't start disassembling until we've set the image buffer.
  uint8_t shellcode[] = {
      0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89,
      0x7C, 0x24, 0x18, 0x55, 0x48, 0x8B, 0xEC, 0x48, 0x83, 0xEC, 0x10, 0xB8,
      0x63, 0x72, 0x65, 0x61, 0xC7, 0x45, 0xF0, 0x37, 0x13, 0x00, 0x00, 0x41,
      0xBA, 0x62, 0x69, 0x6E, 0x67, 0xC7, 0x45, 0xF4, 0x69, 0x00, 0x00, 0x00,
      0xC7, 0x45, 0xF8, 0x20, 0x04, 0x00, 0x00, 0xBB, 0x80, 0x96, 0x98, 0x00,
      0xC7, 0x45, 0xFC, 0x66, 0x06, 0x00, 0x00, 0xBE, 0x40, 0x6E, 0xDE, 0x8D,
      0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x45,
      0x33, 0xC0, 0x45, 0x8D, 0x59, 0x04, 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00,
      0x41, 0x83, 0xE0, 0x03, 0x8B, 0xC8, 0xC1, 0xE1, 0x04, 0x8B, 0xD0, 0xC1,
      0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x03, 0xD0, 0x41,
      0x03, 0xC9, 0x41, 0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E, 0x33, 0xD1, 0x45,
      0x8B, 0xC1, 0x44, 0x03, 0xD2, 0x41, 0x83, 0xE0, 0x03, 0x41, 0x8B, 0xCA,
      0x41, 0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41,
      0x8B, 0xC9, 0x48, 0xC1, 0xE9, 0x0B, 0x41, 0x03, 0xD2, 0x83, 0xE1, 0x03,
      0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B,
      0xC8, 0x8B, 0xD0, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42,
      0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9, 0x03, 0xD0, 0x33, 0xD1, 0x41,
      0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E, 0x44, 0x03, 0xD2, 0x45, 0x8B, 0xC1,
      0x41, 0x8B, 0xCA, 0x41, 0x83, 0xE0, 0x03, 0xC1, 0xE1, 0x04, 0x41, 0x8B,
      0xD2, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48, 0xC1, 0xE9,
      0x0B, 0x41, 0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41,
      0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xC8, 0x8B, 0xD0, 0xC1, 0xE1,
      0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41,
      0x03, 0xC9, 0x03, 0xD0, 0x33, 0xD1, 0x41, 0x81, 0xC1, 0xB9, 0x79, 0x37,
      0x9E, 0x44, 0x03, 0xD2, 0x45, 0x8B, 0xC1, 0x41, 0x8B, 0xCA, 0x41, 0x8B,
      0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9,
      0x48, 0xC1, 0xE9, 0x0B, 0x41, 0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C,
      0x8D, 0xF0, 0x41, 0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xD0, 0x8B,
      0xC8, 0xC1, 0xEA, 0x05, 0xC1, 0xE1, 0x04, 0x41, 0x83, 0xE0, 0x03, 0x33,
      0xD1, 0x03, 0xD0, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9, 0x41,
      0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E, 0x33, 0xD1, 0x45, 0x8B, 0xC1, 0x44,
      0x03, 0xD2, 0x41, 0x83, 0xE0, 0x03, 0x41, 0x8B, 0xCA, 0x41, 0x8B, 0xD2,
      0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48,
      0xC1, 0xE9, 0x0B, 0x41, 0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D,
      0xF0, 0x41, 0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xC8, 0x8B, 0xD0,
      0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85,
      0xF0, 0x41, 0x03, 0xC9, 0x03, 0xD0, 0x33, 0xD1, 0x41, 0x81, 0xC1, 0xB9,
      0x79, 0x37, 0x9E, 0x44, 0x03, 0xD2, 0x45, 0x8B, 0xC1, 0x41, 0x8B, 0xCA,
      0x41, 0x83, 0xE0, 0x03, 0xC1, 0xE1, 0x04, 0x41, 0x8B, 0xD2, 0xC1, 0xEA,
      0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48, 0xC1, 0xE9, 0x0B, 0x41, 0x03,
      0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xC9, 0x33,
      0xD1, 0x03, 0xC2, 0x8B, 0xC8, 0x8B, 0xD0, 0xC1, 0xE1, 0x04, 0xC1, 0xEA,
      0x05, 0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9, 0x03,
      0xD0, 0x33, 0xD1, 0x41, 0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E, 0x44, 0x03,
      0xD2, 0x45, 0x8B, 0xC1, 0x41, 0x8B, 0xCA, 0x41, 0x8B, 0xD2, 0xC1, 0xE1,
      0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48, 0xC1, 0xE9,
      0x0B, 0x41, 0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41,
      0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xD0, 0x8B, 0xC8, 0xC1, 0xEA,
      0x05, 0xC1, 0xE1, 0x04, 0x33, 0xD1, 0x03, 0xD0, 0x41, 0x83, 0xE0, 0x03,
      0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9, 0x41, 0x81, 0xC1, 0xB9,
      0x79, 0x37, 0x9E, 0x33, 0xD1, 0x45, 0x8B, 0xC1, 0x44, 0x03, 0xD2, 0x41,
      0x83, 0xE0, 0x03, 0x41, 0x8B, 0xCA, 0x41, 0x8B, 0xD2, 0xC1, 0xE1, 0x04,
      0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48, 0xC1, 0xE9, 0x0B,
      0x41, 0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03,
      0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xC8, 0x8B, 0xD0, 0xC1, 0xE1, 0x04,
      0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03,
      0xC9, 0x03, 0xD0, 0x33, 0xD1, 0x41, 0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E,
      0x44, 0x03, 0xD2, 0x45, 0x8B, 0xC1, 0x41, 0x83, 0xE0, 0x03, 0x41, 0x8B,
      0xCA, 0xC1, 0xE1, 0x04, 0x41, 0x8B, 0xD2, 0xC1, 0xEA, 0x05, 0x33, 0xD1,
      0x41, 0x8B, 0xC9, 0x48, 0xC1, 0xE9, 0x0B, 0x41, 0x03, 0xD2, 0x83, 0xE1,
      0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2,
      0x8B, 0xC8, 0x8B, 0xD0, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1,
      0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9, 0x03, 0xD0, 0x33, 0xD1,
      0x41, 0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E, 0x44, 0x03, 0xD2, 0x45, 0x8B,
      0xC1, 0x41, 0x8B, 0xCA, 0x41, 0x83, 0xE0, 0x03, 0xC1, 0xE1, 0x04, 0x41,
      0x8B, 0xD2, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48, 0xC1,
      0xE9, 0x0B, 0x41, 0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0,
      0x41, 0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xD0, 0x8B, 0xC8, 0xC1,
      0xEA, 0x05, 0xC1, 0xE1, 0x04, 0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0,
      0x03, 0xD0, 0x41, 0x03, 0xC9, 0x33, 0xD1, 0x41, 0x81, 0xC1, 0xB9, 0x79,
      0x37, 0x9E, 0x44, 0x03, 0xD2, 0x45, 0x8B, 0xC1, 0x41, 0x83, 0xE0, 0x03,
      0x41, 0x8B, 0xCA, 0xC1, 0xE1, 0x04, 0x41, 0x8B, 0xD2, 0xC1, 0xEA, 0x05,
      0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48, 0xC1, 0xE9, 0x0B, 0x41, 0x03, 0xD2,
      0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xC9, 0x33, 0xD1,
      0x03, 0xC2, 0x8B, 0xC8, 0x8B, 0xD0, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05,
      0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9, 0x03, 0xD0,
      0x33, 0xD1, 0x41, 0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E, 0x44, 0x03, 0xD2,
      0x45, 0x8B, 0xC1, 0x41, 0x8B, 0xCA, 0x41, 0x83, 0xE0, 0x03, 0xC1, 0xE1,
      0x04, 0x41, 0x8B, 0xD2, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9,
      0x48, 0xC1, 0xE9, 0x0B, 0x41, 0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C,
      0x8D, 0xF0, 0x41, 0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xC8, 0x8B,
      0xD0, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B, 0x4C,
      0x85, 0xF0, 0x41, 0x03, 0xC9, 0x03, 0xD0, 0x33, 0xD1, 0x41, 0x81, 0xC1,
      0xB9, 0x79, 0x37, 0x9E, 0x44, 0x03, 0xD2, 0x45, 0x8B, 0xC1, 0x41, 0x8B,
      0xCA, 0x41, 0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0x41, 0x83, 0xE0, 0x03, 0xC1,
      0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48, 0xC1, 0xE9, 0x0B, 0x41,
      0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xC9,
      0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xD0, 0x8B, 0xC8, 0xC1, 0xEA, 0x05, 0xC1,
      0xE1, 0x04, 0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9,
      0x03, 0xD0, 0x33, 0xD1, 0x44, 0x03, 0xD2, 0x41, 0x81, 0xC1, 0xB9, 0x79,
      0x37, 0x9E, 0x45, 0x8B, 0xC1, 0x41, 0x8B, 0xCA, 0xC1, 0xE1, 0x04, 0x41,
      0x83, 0xE0, 0x03, 0x41, 0x8B, 0xD2, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41,
      0x8B, 0xC9, 0x41, 0x03, 0xD2, 0x48, 0xC1, 0xE9, 0x0B, 0x83, 0xE1, 0x03,
      0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B,
      0xC8, 0x8B, 0xD0, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42,
      0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9, 0x03, 0xD0, 0x33, 0xD1, 0x41,
      0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E, 0x44, 0x03, 0xD2, 0x45, 0x8B, 0xC1,
      0x41, 0x83, 0xE0, 0x03, 0x41, 0x8B, 0xCA, 0xC1, 0xE1, 0x04, 0x41, 0x8B,
      0xD2, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x41, 0x03, 0xD2,
      0x48, 0xC1, 0xE9, 0x0B, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41,
      0x03, 0xC9, 0x33, 0xD1, 0x03, 0xC2, 0x8B, 0xC8, 0x8B, 0xD0, 0xC1, 0xEA,
      0x05, 0xC1, 0xE1, 0x04, 0x33, 0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41,
      0x03, 0xC9, 0x03, 0xD0, 0x33, 0xD1, 0x41, 0x81, 0xC1, 0xB9, 0x79, 0x37,
      0x9E, 0x44, 0x03, 0xD2, 0x45, 0x8B, 0xC1, 0x41, 0x8B, 0xCA, 0x41, 0x83,
      0xE0, 0x03, 0xC1, 0xE1, 0x04, 0x41, 0x8B, 0xD2, 0xC1, 0xEA, 0x05, 0x33,
      0xD1, 0x41, 0x8B, 0xC9, 0x41, 0x03, 0xD2, 0x48, 0xC1, 0xE9, 0x0B, 0x83,
      0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xC9, 0x33, 0xD1, 0x03,
      0xC2, 0x8B, 0xD0, 0x8B, 0xC8, 0xC1, 0xEA, 0x05, 0xC1, 0xE1, 0x04, 0x33,
      0xD1, 0x42, 0x8B, 0x4C, 0x85, 0xF0, 0x41, 0x03, 0xC9, 0x03, 0xD0, 0x33,
      0xD1, 0x41, 0x81, 0xC1, 0xB9, 0x79, 0x37, 0x9E, 0x44, 0x03, 0xD2, 0x45,
      0x8B, 0xC1, 0x41, 0x8B, 0xD2, 0xC1, 0xEA, 0x05, 0x41, 0x8B, 0xCA, 0xC1,
      0xE1, 0x04, 0x33, 0xD1, 0x41, 0x8B, 0xC9, 0x48, 0xC1, 0xE9, 0x0B, 0x41,
      0x03, 0xD2, 0x83, 0xE1, 0x03, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xC9,
      0x33, 0xD1, 0x03, 0xC2, 0x49, 0x83, 0xEB, 0x01, 0x0F, 0x85, 0x06, 0xFB,
      0xFF, 0xFF, 0x44, 0x8B, 0xDE, 0x4C, 0x8B, 0xCE, 0xBF, 0x04, 0x00, 0x00,
      0x00, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x49, 0xC1, 0xE9, 0x0B, 0x41, 0x8B, 0xCA, 0xC1, 0xE1, 0x04, 0x41, 0x83,
      0xE1, 0x03, 0x41, 0x8B, 0xD2, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xD2, 0x41, 0x03, 0xCB, 0x41, 0x81, 0xC3,
      0x47, 0x86, 0xC8, 0x61, 0x33, 0xD1, 0x45, 0x8B, 0xCB, 0x2B, 0xC2, 0x49,
      0xC1, 0xE9, 0x0B, 0x41, 0x83, 0xE1, 0x03, 0x8B, 0xC8, 0xC1, 0xE1, 0x04,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x49,
      0xC1, 0xE9, 0x0B, 0x8B, 0xC8, 0xC1, 0xE1, 0x04, 0x41, 0x83, 0xE1, 0x03,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x8B,
      0xC8, 0x44, 0x8B, 0xC0, 0xC1, 0xE1, 0x04, 0x41, 0xC1, 0xE8, 0x05, 0x44,
      0x33, 0xC1, 0x41, 0x8B, 0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B,
      0x54, 0x8D, 0xF0, 0x41, 0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0,
      0x41, 0x8B, 0xD2, 0x41, 0x8B, 0xCA, 0xC1, 0xEA, 0x05, 0xC1, 0xE1, 0x04,
      0x33, 0xD1, 0x49, 0xC1, 0xE9, 0x0B, 0x41, 0x03, 0xD2, 0x41, 0x83, 0xE1,
      0x03, 0x42, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x81, 0xC3,
      0x47, 0x86, 0xC8, 0x61, 0x33, 0xD1, 0x45, 0x8B, 0xCB, 0x2B, 0xC2, 0x49,
      0xC1, 0xE9, 0x0B, 0x41, 0x83, 0xE1, 0x03, 0x8B, 0xC8, 0xC1, 0xE1, 0x04,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x49,
      0xC1, 0xE9, 0x0B, 0x8B, 0xC8, 0xC1, 0xE1, 0x04, 0x41, 0x83, 0xE1, 0x03,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x8B,
      0xC8, 0x44, 0x8B, 0xC0, 0xC1, 0xE1, 0x04, 0x41, 0xC1, 0xE8, 0x05, 0x44,
      0x33, 0xC1, 0x41, 0x8B, 0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B,
      0x54, 0x8D, 0xF0, 0x41, 0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0,
      0x41, 0x8B, 0xD2, 0x41, 0x8B, 0xCA, 0xC1, 0xEA, 0x05, 0xC1, 0xE1, 0x04,
      0x33, 0xD1, 0x41, 0x03, 0xD2, 0x49, 0xC1, 0xE9, 0x0B, 0x41, 0x83, 0xE1,
      0x03, 0x42, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x81, 0xC3,
      0x47, 0x86, 0xC8, 0x61, 0x33, 0xD1, 0x45, 0x8B, 0xCB, 0x2B, 0xC2, 0x49,
      0xC1, 0xE9, 0x0B, 0x41, 0x83, 0xE1, 0x03, 0x8B, 0xC8, 0xC1, 0xE1, 0x04,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x49,
      0xC1, 0xE9, 0x0B, 0x8B, 0xC8, 0xC1, 0xE1, 0x04, 0x41, 0x83, 0xE1, 0x03,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x8B,
      0xC8, 0x49, 0xC1, 0xE9, 0x0B, 0xC1, 0xE1, 0x04, 0x44, 0x8B, 0xC0, 0x41,
      0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B, 0xCB, 0x83, 0xE1, 0x03,
      0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41, 0x03, 0xD3, 0x44, 0x33,
      0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xD2, 0x41, 0x8B, 0xCA, 0xC1, 0xEA,
      0x05, 0xC1, 0xE1, 0x04, 0x33, 0xD1, 0x41, 0x03, 0xD2, 0x41, 0x83, 0xE1,
      0x03, 0x42, 0x8B, 0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x81, 0xC3,
      0x47, 0x86, 0xC8, 0x61, 0x33, 0xD1, 0x45, 0x8B, 0xCB, 0x2B, 0xC2, 0x49,
      0xC1, 0xE9, 0x0B, 0x41, 0x83, 0xE1, 0x03, 0x8B, 0xC8, 0xC1, 0xE1, 0x04,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x49,
      0xC1, 0xE9, 0x0B, 0x8B, 0xC8, 0xC1, 0xE1, 0x04, 0x41, 0x83, 0xE1, 0x03,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x8B,
      0xC8, 0x49, 0xC1, 0xE9, 0x0B, 0xC1, 0xE1, 0x04, 0x44, 0x8B, 0xC0, 0x41,
      0xC1, 0xE8, 0x05, 0x41, 0x83, 0xE1, 0x03, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xD2, 0x41,
      0x8B, 0xCA, 0xC1, 0xEA, 0x05, 0xC1, 0xE1, 0x04, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x2B,
      0xC2, 0x41, 0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x8B, 0xC8, 0xC1, 0xE1,
      0x04, 0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x45,
      0x8B, 0xCB, 0x44, 0x03, 0xC0, 0x49, 0xC1, 0xE9, 0x0B, 0x41, 0x83, 0xE1,
      0x03, 0x41, 0x8B, 0xCB, 0x83, 0xE1, 0x03, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x49,
      0xC1, 0xE9, 0x0B, 0x8B, 0xC8, 0xC1, 0xE1, 0x04, 0x41, 0x83, 0xE1, 0x03,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xCA, 0x41,
      0x8B, 0xD2, 0xC1, 0xE1, 0x04, 0xC1, 0xEA, 0x05, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x41,
      0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x2B, 0xC2, 0x45, 0x8B, 0xCB, 0x49,
      0xC1, 0xE9, 0x0B, 0x8B, 0xC8, 0xC1, 0xE1, 0x04, 0x41, 0x83, 0xE1, 0x03,
      0x44, 0x8B, 0xC0, 0x41, 0xC1, 0xE8, 0x05, 0x44, 0x33, 0xC1, 0x41, 0x8B,
      0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B, 0x54, 0x8D, 0xF0, 0x41,
      0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0, 0x41, 0x8B, 0xD2, 0x41,
      0x8B, 0xCA, 0xC1, 0xEA, 0x05, 0xC1, 0xE1, 0x04, 0x33, 0xD1, 0x42, 0x8B,
      0x4C, 0x8D, 0xF0, 0x41, 0x03, 0xCB, 0x41, 0x03, 0xD2, 0x33, 0xD1, 0x2B,
      0xC2, 0x41, 0x81, 0xC3, 0x47, 0x86, 0xC8, 0x61, 0x44, 0x8B, 0xC0, 0x45,
      0x8B, 0xCB, 0x41, 0xC1, 0xE8, 0x05, 0x8B, 0xC8, 0xC1, 0xE1, 0x04, 0x44,
      0x33, 0xC1, 0x41, 0x8B, 0xCB, 0x83, 0xE1, 0x03, 0x44, 0x03, 0xC0, 0x8B,
      0x54, 0x8D, 0xF0, 0x41, 0x03, 0xD3, 0x44, 0x33, 0xC2, 0x45, 0x2B, 0xD0,
      0x48, 0x83, 0xEF, 0x01, 0x0F, 0x85, 0xB6, 0xFA, 0xFF, 0xFF, 0x48, 0x83,
      0xEB, 0x01, 0x0F, 0x85, 0x8C, 0xF5, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24,
      0x20, 0x41, 0x33, 0xC2, 0x48, 0x8B, 0x74, 0x24, 0x28, 0x48, 0x8B, 0x7C,
      0x24, 0x30, 0x48, 0x83, 0xC4, 0x10, 0x5D, 0xC3};
  std::string image_buffer;

  image_buffer.assign((char *)shellcode, (char *)shellcode + sizeof(shellcode));
  uint8_t simplefn[] = {0x31, 0xC0, 0xC3};
  // image_buffer.assign((char *)simplefn, (char *)simplefn + sizeof(simplefn));
  uint8_t system[] = {0x0F, 0x05, 0x0F, 0xA2};
  //image_buffer.assign((char *)system, (char *)system + sizeof(system));

  auto len = image_buffer.size();
  load_image.SetImageBuffer(std::move(image_buffer));

  std::cout << "chujka\n";
  if (args->action == "disassemble") {
    PrintAssembly(engine, addr, len);
  } else if (args->action == "pcode") {
    PrintPcode(engine, addr, len);
  } else if (args->action == "emulate") {
    try {
      EmulatePcode(engine, addr, len, load_image);
    } catch (LowlevelError &x) {
      puts(x.explain.c_str());
    }
  } else {
    std::cerr << "Invalid action: " << args->action << std::endl;
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
